% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stat-apply.R
\name{stat_apply_group}
\alias{stat_apply_group}
\alias{stat_apply_panel}
\alias{stat_summary_xy}
\alias{stat_centroid}
\title{Apply a function to x or y values}
\usage{
stat_apply_group(
  mapping = NULL,
  data = NULL,
  geom = "line",
  .fun.x = NULL,
  .fun.x.args = list(),
  .fun.y = NULL,
  .fun.y.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_apply_panel(
  mapping = NULL,
  data = NULL,
  geom = "line",
  .fun.x = NULL,
  .fun.x.args = list(),
  .fun.y = NULL,
  .fun.y.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_summary_xy(
  mapping = NULL,
  data = NULL,
  geom = "point",
  .fun.x = NULL,
  .fun.x.args = list(),
  .fun.y = NULL,
  .fun.y.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)

stat_centroid(
  mapping = NULL,
  data = NULL,
  geom = "point",
  .fun = mean,
  .fun.args = list(),
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  ...
)
}
\arguments{
\item{mapping}{The aesthetic mapping, usually constructed with
\code{\link[ggplot2]{aes}}. Only needs to be set at the layer level if you
are overriding the plot defaults.}

\item{data}{A layer specific dataset - only needed if you want to override
the plot defaults.}

\item{geom}{The geometric object to use display the data}

\item{.fun.x, .fun.y, .fun}{function to be applied or the name of the function
to be applied as a character string.}

\item{.fun.x.args, .fun.y.args, .fun.args}{additional arguments to be passed to
the function as a named list.}

\item{position}{The position adjustment to use for overlapping points on this
layer}

\item{na.rm}{a logical value indicating whether NA values should be stripped
before the computation proceeds.}

\item{show.legend}{logical. Should this layer be included in the legends?
\code{NA}, the default, includes if any aesthetics are mapped. \code{FALSE}
never includes, and \code{TRUE} always includes.}

\item{inherit.aes}{If \code{FALSE}, overrides the default aesthetics, rather
than combining with them. This is most useful for helper functions that
define both data and aesthetics and shouldn't inherit behaviour from the
default plot specification, e.g. \code{\link[ggplot2]{borders}}.}

\item{...}{other arguments passed on to \code{\link[ggplot2]{layer}}. This
can include aesthetics whose values you want to set, not map. See
\code{\link[ggplot2]{layer}} for more details.}
}
\value{
A data frame with the same variables as in the input, with either a
   single or multiple rows, with the values of x and y variables replaced by
   the values returned by the applied functions, or possibly filled if no
   function was supplied or available by default.

A plot layer instance. Using as output \code{data} the in input
  \code{data} after application of a function.
}
\description{
\code{stat_summary_xy()} and \code{stat_centroid()} are similar to
\code{ggplot2::stat_summary()} but summarize both \code{x} and \code{y}
values in parallel in the same plot layer.
}
\details{
\code{stat_apply_group} and \code{stat_apply_panel} apply functions to data.
In most cases one should simply use transformations through scales or summary
functions such as \code{ggplot2::stat_summary()}, \code{stat_summary_xy()} or
\code{stat_centroid()}. There are some computations that are not scale
transformations but are not usual summaries either, as the number of data
values does not decrease to one row per group. It is always possible to
precompute quantities like cumulative sums or running medians, and for
normalizations it can be convenient to apply such functions on-the-fly to
ensure that grouping is consistent between computations and aesthetics. One
particularity of these statistics is that they can apply simultaneously
different functions to \code{x} values and to \code{y} values when needed. In
contrast to these statistics, \code{\link[ggplot2]{geom_smooth}} applies a
function that takes both \code{x} and \code{y} values as arguments.

These four statistics are very similar and are implemented using the
  same internal function. They differ on whether this function is applied by
  group or by panel, and whether they return a single or multiple rows of
  data.
}
\note{
The applied function(s) must accept as first argument a vector that
  matches the variables mapped to \code{x} and \code{y} aesthetics. For
  \code{stat_summary_xy()} and \code{stat_centroid()} the function(s) to be
  applied is/are expected to return a vector of length
  1, while for \code{stat_apply_group} and \code{stat_apply_panel} the
  vectors returned by the functions applied to \code{x} and \code{y} must
  return vectors of exactly the same length. When only one of
  \code{.fun.x} or \code{.fun.y} are passed a function as argument, and the
  returned value is shorter than the data, the values of the other variable
  in the returned data are filled with the median.
}
\section{Computed variables}{
 One of x or y or both x and y replaced by the
  vector returned by the corresponding applied function. \describe{
  \item{x}{x-value as returned by \code{.fun.x}} \item{y}{y-value as returned
  by \code{.fun.y}} }
}

\examples{
library(gginnards)
set.seed(123456)
my.df <- data.frame(X = rep(1:20,2),
                    Y = runif(40),
                    category = rep(c("A","B"), each = 20))

# make sure rows are ordered for X as we will use functions that rely on this
my.df <- my.df[order(my.df[["X"]]), ]

# Centroid
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(shape = "cross", size = 6) +
  geom_point()

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(geom = "rug", size = 1.5, .fun = median) +
  geom_point()

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(geom = "text", aes(label = category)) +
  geom_point()

# quantiles
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(geom = "rug", .fun.y = quantile, .fun.x = quantile)

my.probs <- c(0.25, 0.5, 0.75)
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(geom = "hline",
                   aes(yintercept = after_stat(y)),
                   .fun.y = quantile,
                   .fun.y.args = list(probs = my.probs))#'

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(geom = "debug",
                   .fun.x = function(x) {rep_len(min(x), 3L)},
                   .fun.y = quantile,
                   .fun.y.args = list(probs = my.probs))

# Use of geom_debug() to inspect the computed values
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.y = cumsum, geom = "debug")

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.y = cummax)

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.x = cumsum, .fun.y = cumsum)

# diff returns a shorter vector by 1 for each group
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.y = diff, na.rm = TRUE)

ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  geom_point() +
  stat_apply_group(.fun.y = runmed, .fun.y.args = list(k = 5))

# Rescaling per group
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_group(.fun.y = function(x) {(x - min(x)) / (max(x) - min(x))})

# Joint rescaling for whole panel
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_apply_panel(.fun.y = function(x) {(x - min(x)) / (max(x) - min(x))})

# Centroid
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(shape = "cross", size = 6) +
  geom_point()

# Centroid
ggplot(my.df, aes(x = X, y = Y, colour = category)) +
  stat_centroid(geom = "text", aes(label = category)) +
  geom_point()

}
\references{
Answers question "R ggplot on-the-fly calculation by grouping variable" at
\url{https://stackoverflow.com/questions/51412522}.
}
\concept{summary stats}
